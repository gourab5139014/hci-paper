In order to create a representative sample of the workload, we need to identify patterns in the query log. The task of identifying patterns directly from the log is difficult. A naive approach would be to consider individual queries as atomic components of the query logs and cluster them by directly extracting features. The most important difference between a smartphone database workload and that in database servers are the users' bursts of activity. Most benchmarks like the TPC-C focus on emulating homogenous query workloads of an OLTP system. Their goal is to analyse throughput fpr these homogenous workloads. But it is not correct to truly emulate smartphone query workloads without emulating the inermittent bursts of query activity. These bursts can only be detected by looking at the chronological attributes like query timestamp and query interarrival time. This approach does not consider the chronological ordering of the queries. Hence, This naive clustering is not meaningful. Another level of abstraction is needed to extract meaningful patterns from the query log.

We introduce the concept of sessions to solve this problem. A user would interact with their smartphone multiple times a day for small intervals of time. These bursts of intermittent activity are captured in database user sessions. These form the atomic units of the query log which can be used for detecting patterns. 

A logical task performed by a user on a smartphone, such as checking for new email, might produce multiple queries to the database. Since smartphone applications keep switching between foreground and background, these queries could be arbitrarily spaced out in time. Hence, one database user session might contain one or more logical user tasks. A logical user task might be spread across multiple database user sessions. These sessions are useful in capture subset of logical tasks which are repetitive. Since there is no discrete indicator of the start and end of a database user session in smartphones, we use a heuristic to help define one. If queries in a log are apart in time beyond a threshold, we consider them to be a part of different sessions.

%\todo{Talk about: no one-to-one mapping between sessions and activities. Mobile users might perform the same activity in a single session.
%Other challenge... can't get good session cutoff points. }
Even though we have now obtained an atomic unit of a quqery log for the purpose of detecting patterns, the problem of poor clustering owing to directly extracting features still remains to be addressed. We introduce another level of abstraction to segregate queries based on their interest over database attributes. This is determined by similarity in their semantic structure. Since most of the queries issued to a smartphone database are made through ORMs, they contain ingerent structure. Each query can belong to one of many query clusters. This makes the detection of patterns easier.  

To summarize, we perform a two step preprocessing : Clustering and Session Identification. Our system operates in three stages: (1)~A \textbf{clustering} phase where the queries in the log are segregated by similarity in their semantic structure, (2)~A \textbf{session identification} phase where the query logs are partitioned based on the timing of queries to identify the length and coverage of individual user sessions, and (3)~A \textbf{session parameter detection} phase where the partitioned sessions are inspected in order to establish associations of what kinds of activities are performed together in a typical session, as well as detection of unusual activities. These stages are illustrated in Figure~\ref{fig:abstractview}. 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{graphics/systemoutline}
    \caption{Abstract view of inputs and outputs. (a) Clustering (b) Session Identification}
    \label{fig:abstractview}
\end{figure}


\subsection{Clustering phase}

The query workload created by an Android application consists of queries generated by user activity.
Most of the applications support several functionalities, and these functionalities generate queries with conditions based on the user needs.

In this phase, we aim to distinguish these functionalities based on the variety of structural differences in queries.
We observe and process every SQL query issued to the mobile DBMS.
We extract the relevant features of the query considering what kind of attributes the query is accessing with that particular query.
Our work follows the basic SQL query feature extraction principles of Makiyama \textit{et al.}~\cite{makiyama2015text}.
Using these query features, we construct a feature vector for each query to cluster similar queries together.
We use hierarchical clustering since there is not a specific number of clusters we need. 
This step provides us with the information required to see frequency of different kinds of queries a user issues.

\todo{Talk about what is novel and what has already been done before.}

\subsection{Session identification phase}
The usage pattern of databases in smartphones differs significantly from the continuous patterns experienced in database servers~\cite{kennedy2015pocket} or more traditional computing devices like PCs.  
%Most modern day smartphones rely on some kind of a web service to help a mobile application deliver the desired functionality to the user.
%This introduces various new application design considerations.
%User sessions in context of smartphones might not be similar to a session on other more traditional computing devices like PCs.
Typically, an end user would use their smartphones multiple times a day for small intervals of time. This pattern of intermittent bursts of activity motivates a new way of looking at these usage patterns. Identification of patterns would require breaking down the workload into logical units which can be compared for similarity. These logical units can be formed by ``slicing'' the chronologically ordered queries in the workload. Every unit represents a task that the user performs in a burst of activity. Such tasks are comprised of a bag of queries. We refer to these logical units as database sessions.
%In context of a single mobile application, the user would access multiple logical transactions in these bursts of activities; the queries issued by the application are machine/ORM generated. Thus, there is an inherent structure.
%Intuitively, a user session is quite straightforward to understand, but its technical  aspects require defining.

%Some smartphone usage studies define a session as the time period where the smartphone's screen is active~\cite{soikkeli2011diversity}.
%Smartphone usage is dominated by usage of the applications that the smartphone has to offer.
%Thus, the idea of a smartphone usage session can be reduced to an application usage session.
%This is relevant to us because we aim to study the interaction with the smartphone database through understanding a single application.
%Mobile users must be able to work without a network connection due to poor or non-existent connection.
%In that case, a mobile database serves as a cache to hold recently accessed data and transactions so that they are not lost due to connection failure.
%In many cases, users might not expect live data during connection failures; only recently modified data.
%Update of recent changes and downloading of live data can be deferred until connection is restored.

\note{To Gourab: the rest of the section is moved to the methodology section.}

%In our framework, a \textit{database session} is a logical unit of user interaction. It spans over a period of time and comprises of sequential queries. If two sequential queries are more than \textit{t} seconds apart, we consider them to be in different sessions. Parameter \textit{t} is called the Idle Time Tolerance. 
%%In our framework, a \textit{database session} on a smartphone is a time period in which the user's activity makes the application issue sequential queries with a period of at most \textit{t} seconds between them.
%%We identify the approximate the time \textit{t} for each user to find what constitutes of a session for each user.
%Large values of \textit{t} would create sessions which span longer amounts of time. These bloated sessions would capture multiple tasks which would reduce the granuarity of subsequent processing. On the other hand, very small values of \textit{t} would create very small sessions which span minuscule amounts of time and contain very less queries. Such tiny sessions might not capture complete tasks.

%We incrementally iterate different idle time tolerances \textit{t} and look at the corresponding number of sessions that are obtained. The optimum value of \textit{t} is obtained by locating the knee or trade-off point. The non-optimum values of \textit{t} would require an unfavorably large change in one of the quantities to gain a small amount in the other. 
%%We incrementally iterate different idle time tolerances \textit{t}, and determine the ideal \textit{t} when incrementing it starts not to affect the number of sessions identified.

\subsection{Session parameter detection phase}

Another aspect of generating a query workload is to be able to imitate the length and timings of the sessions created by the users as well as the deviations from this behavior. In the session parameter detection phase, we identify the user interests via query features created by the user, determine the session lengths and query counts in a session, and compute the difference between sessions in order to capture the unusual activities.

We treat sessions as entities that aim to perform a bag of tasks.
To automatically generate synthetic workloads, we extract the minimum and maximum session lengths, typical query counts, and the features encountered in each session.

\todo{Gourab: I suggest moving out implementation details from Para 2 to another section}
\todo{Talk about what is novel and what has already been done before.}


